/**
 * Security Vulnerability Scanner
 * Comprehensive security testing for web applications
 */

const { chromium } = require('playwright');
const fs = require('fs');
const crypto = require('crypto');

class SecurityScanner {
    constructor() {
        this.results = {
            timestamp: new Date().toISOString(),
            vulnerabilities: [],
            summary: {
                critical: 0,
                high: 0,
                medium: 0,
                low: 0,
                info: 0
            }
        };
        
        this.testPages = [
            { name: 'Professional Design Report', path: '/Users/blakelange/Downloads/Mohave_Professional_Design_Report.html' },
            { name: 'Comprehensive Technical Report', path: '/Users/blakelange/Downloads/Mohave_Comprehensive_Technical_Report.html' },
            { name: '3D Facility Visualization', path: '/Users/blakelange/Downloads/Mohave_Complete_Facility_3D_Analysis.html' },
            { name: 'Enhanced 3D Professional Analysis', path: '/Users/blakelange/Downloads/Mohave_Enhanced_3D_ZIndex_FINAL_FIX.html' },
            { name: 'White Label Report Builder', path: '/Users/blakelange/Downloads/Mohave_White_Label_Report_Builder.html' }
        ];

        this.xssPayloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            'javascript:alert("XSS")',
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            '${alert("XSS")}',
            '{{constructor.constructor("alert(\\"XSS\\")")()}}',
            '<iframe src="javascript:alert(\\"XSS\\")">',
            '<body onload=alert("XSS")>',
            '<input onfocus=alert("XSS") autofocus>'
        ];

        this.injectionPayloads = [
            "'; DROP TABLE users; --",
            "1' OR '1'='1",
            "admin'--",
            "' UNION SELECT * FROM users--",
            "1; DELETE FROM users; --",
            "' OR 1=1#",
            "admin'; EXEC xp_cmdshell('dir'); --",
            "' OR 'a'='a",
            "1' ORDER BY 1--+",
            "' HAVING 1=1--"
        ];
    }

    async runSecurityScan() {
        console.log('üõ°Ô∏è  COMPREHENSIVE SECURITY VULNERABILITY SCAN');
        console.log('‚ïê'.repeat(60));
        console.log('Scanning for XSS, Injection, CSP, and other vulnerabilities...\n');

        const browser = await chromium.launch({ headless: true });

        for (const page of this.testPages) {
            console.log(`üîç Scanning: ${page.name}`);
            console.log('‚îÄ'.repeat(40));
            
            const browserPage = await browser.newPage();
            
            try {
                await this.scanPage(browserPage, page);
            } catch (error) {
                this.addVulnerability({
                    page: page.name,
                    type: 'SCAN_ERROR',
                    severity: 'HIGH',
                    description: `Failed to scan page: ${error.message}`,
                    impact: 'Cannot assess security posture',
                    recommendation: 'Fix page loading issues before security assessment'
                });
            }
            
            await browserPage.close();
        }

        await browser.close();
        await this.generateSecurityReport();
    }

    async scanPage(page, pageInfo) {
        // Load page with security monitoring
        await page.goto(`file://${pageInfo.path}`, { 
            waitUntil: 'networkidle',
            timeout: 30000 
        });

        // Test 1: Content Security Policy
        await this.testCSP(page, pageInfo.name);

        // Test 2: XSS Vulnerabilities
        await this.testXSS(page, pageInfo.name);

        // Test 3: Input Validation
        await this.testInputValidation(page, pageInfo.name);

        // Test 4: Information Disclosure
        await this.testInformationDisclosure(page, pageInfo.name);

        // Test 5: Client-side Storage Security
        await this.testStorageSecurity(page, pageInfo.name);

        // Test 6: JavaScript Security
        await this.testJavaScriptSecurity(page, pageInfo.name);

        // Test 7: Third-party Dependencies
        await this.testThirdPartyDependencies(page, pageInfo.name);

        // Test 8: Authentication/Authorization
        await this.testAuthSecurity(page, pageInfo.name);

        // Test 9: Error Handling
        await this.testErrorHandling(page, pageInfo.name);

        // Test 10: Data Exposure
        await this.testDataExposure(page, pageInfo.name);
    }

    async testCSP(page, pageName) {
        try {
            const cspHeaders = await page.evaluate(() => {
                const metaTags = Array.from(document.querySelectorAll('meta[http-equiv="Content-Security-Policy"]'));
                return metaTags.map(tag => tag.getAttribute('content'));
            });

            if (cspHeaders.length === 0) {
                this.addVulnerability({
                    page: pageName,
                    type: 'MISSING_CSP',
                    severity: 'HIGH',
                    description: 'No Content Security Policy detected',
                    impact: 'Increased risk of XSS attacks and data injection',
                    recommendation: 'Implement strict Content Security Policy headers',
                    evidence: 'No CSP meta tags or headers found'
                });
            } else {
                // Analyze CSP strength
                const csp = cspHeaders[0];
                if (csp.includes('unsafe-inline') || csp.includes('unsafe-eval')) {
                    this.addVulnerability({
                        page: pageName,
                        type: 'WEAK_CSP',
                        severity: 'MEDIUM',
                        description: 'Content Security Policy allows unsafe operations',
                        impact: 'Reduced protection against XSS attacks',
                        recommendation: 'Remove unsafe-inline and unsafe-eval from CSP',
                        evidence: `CSP: ${csp}`
                    });
                }
            }
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  CSP test failed: ${error.message}`);
        }
    }

    async testXSS(page, pageName) {
        try {
            const inputs = await page.$$('input, textarea, [contenteditable="true"]');
            
            for (let i = 0; i < Math.min(inputs.length, 5); i++) {
                for (const payload of this.xssPayloads.slice(0, 3)) {
                    try {
                        await inputs[i].fill(payload);
                        await page.waitForTimeout(100);
                        
                        // Check if XSS executed
                        const alertFired = await page.evaluate(() => {
                            return window.xssTriggered || false;
                        });
                        
                        if (alertFired) {
                            this.addVulnerability({
                                page: pageName,
                                type: 'XSS_REFLECTED',
                                severity: 'CRITICAL',
                                description: 'Cross-Site Scripting vulnerability detected',
                                impact: 'Attackers can execute arbitrary JavaScript',
                                recommendation: 'Implement proper input sanitization and output encoding',
                                evidence: `Payload: ${payload}`
                            });
                        }
                    } catch (e) {
                        // Input might not accept this type of data
                    }
                }
            }

            // Test for DOM-based XSS
            await this.testDOMXSS(page, pageName);
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  XSS test failed: ${error.message}`);
        }
    }

    async testDOMXSS(page, pageName) {
        try {
            const domSinks = await page.evaluate(() => {
                const sinks = [];
                
                // Check for dangerous DOM sinks
                if (document.body.innerHTML.includes('eval(')) sinks.push('eval() usage detected');
                if (document.body.innerHTML.includes('innerHTML')) sinks.push('innerHTML usage detected');
                if (document.body.innerHTML.includes('document.write')) sinks.push('document.write usage detected');
                if (document.body.innerHTML.includes('location.href')) sinks.push('location.href manipulation detected');
                
                return sinks;
            });

            domSinks.forEach(sink => {
                this.addVulnerability({
                    page: pageName,
                    type: 'DOM_XSS_RISK',
                    severity: 'MEDIUM',
                    description: 'Potential DOM-based XSS vulnerability',
                    impact: 'Client-side code injection possible',
                    recommendation: 'Review and sanitize DOM manipulation code',
                    evidence: sink
                });
            });
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  DOM XSS test failed: ${error.message}`);
        }
    }

    async testInputValidation(page, pageName) {
        try {
            const forms = await page.$$('form');
            
            for (const form of forms) {
                const inputs = await form.$$('input, textarea, select');
                
                for (const input of inputs) {
                    const inputType = await input.getAttribute('type');
                    
                    // Test for missing validation
                    const hasValidation = await input.evaluate(el => {
                        return el.hasAttribute('required') || 
                               el.hasAttribute('pattern') || 
                               el.hasAttribute('minlength') || 
                               el.hasAttribute('maxlength') ||
                               el.hasAttribute('min') || 
                               el.hasAttribute('max');
                    });
                    
                    if (!hasValidation && inputType !== 'hidden') {
                        this.addVulnerability({
                            page: pageName,
                            type: 'MISSING_INPUT_VALIDATION',
                            severity: 'MEDIUM',
                            description: 'Input field lacks client-side validation',
                            impact: 'Invalid or malicious data may be processed',
                            recommendation: 'Add appropriate input validation attributes',
                            evidence: `Input type: ${inputType || 'text'}`
                        });
                    }
                }
            }
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Input validation test failed: ${error.message}`);
        }
    }

    async testInformationDisclosure(page, pageName) {
        try {
            const pageSource = await page.content();
            
            // Check for sensitive information in HTML
            const sensitivePatterns = [
                { pattern: /password\s*[:=]\s*["'][^"']+["']/gi, type: 'Hardcoded Password' },
                { pattern: /api[_-]?key\s*[:=]\s*["'][^"']+["']/gi, type: 'API Key' },
                { pattern: /secret\s*[:=]\s*["'][^"']+["']/gi, type: 'Secret Token' },
                { pattern: /private[_-]?key\s*[:=]\s*["'][^"']+["']/gi, type: 'Private Key' },
                { pattern: /token\s*[:=]\s*["'][^"']+["']/gi, type: 'Authentication Token' },
                { pattern: /mongodb:\/\/[^"'\s]+/gi, type: 'Database Connection String' },
                { pattern: /mysql:\/\/[^"'\s]+/gi, type: 'Database Connection String' },
                { pattern: /postgres:\/\/[^"'\s]+/gi, type: 'Database Connection String' }
            ];

            sensitivePatterns.forEach(({ pattern, type }) => {
                const matches = pageSource.match(pattern);
                if (matches) {
                    matches.forEach(match => {
                        this.addVulnerability({
                            page: pageName,
                            type: 'INFORMATION_DISCLOSURE',
                            severity: 'HIGH',
                            description: `Sensitive information exposed in source code: ${type}`,
                            impact: 'Credentials or secrets may be compromised',
                            recommendation: 'Remove sensitive data from client-side code',
                            evidence: `Found: ${match.substring(0, 50)}...`
                        });
                    });
                }
            });

            // Check for commented-out sensitive data
            const comments = pageSource.match(/<!--[\s\S]*?-->/g) || [];
            comments.forEach(comment => {
                if (/password|secret|key|token/i.test(comment)) {
                    this.addVulnerability({
                        page: pageName,
                        type: 'SENSITIVE_COMMENTS',
                        severity: 'MEDIUM',
                        description: 'Sensitive information in HTML comments',
                        impact: 'Information leakage through source code',
                        recommendation: 'Remove sensitive comments from production code',
                        evidence: `Comment: ${comment.substring(0, 100)}...`
                    });
                }
            });
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Information disclosure test failed: ${error.message}`);
        }
    }

    async testStorageSecurity(page, pageName) {
        try {
            const storageData = await page.evaluate(() => {
                const localStorage = {};
                const sessionStorage = {};
                
                // Check localStorage
                for (let i = 0; i < window.localStorage.length; i++) {
                    const key = window.localStorage.key(i);
                    localStorage[key] = window.localStorage.getItem(key);
                }
                
                // Check sessionStorage
                for (let i = 0; i < window.sessionStorage.length; i++) {
                    const key = window.sessionStorage.key(i);
                    sessionStorage[key] = window.sessionStorage.getItem(key);
                }
                
                return { localStorage, sessionStorage };
            });

            // Check for sensitive data in storage
            [storageData.localStorage, storageData.sessionStorage].forEach((storage, index) => {
                const storageType = index === 0 ? 'localStorage' : 'sessionStorage';
                
                Object.entries(storage).forEach(([key, value]) => {
                    if (/password|secret|token|key|credential/i.test(key) || 
                        /password|secret|token|key|credential/i.test(value)) {
                        this.addVulnerability({
                            page: pageName,
                            type: 'INSECURE_STORAGE',
                            severity: 'HIGH',
                            description: `Sensitive data stored in ${storageType}`,
                            impact: 'Sensitive information accessible via JavaScript',
                            recommendation: 'Avoid storing sensitive data in browser storage',
                            evidence: `Key: ${key}`
                        });
                    }
                });
            });
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Storage security test failed: ${error.message}`);
        }
    }

    async testJavaScriptSecurity(page, pageName) {
        try {
            const jsIssues = await page.evaluate(() => {
                const issues = [];
                
                // Check for eval usage
                if (window.eval.toString().includes('[native code]')) {
                    const scripts = Array.from(document.querySelectorAll('script'));
                    scripts.forEach((script, index) => {
                        if (script.innerHTML.includes('eval(')) {
                            issues.push(`eval() usage in script ${index + 1}`);
                        }
                    });
                }
                
                // Check for setTimeout/setInterval with string
                const originalSetTimeout = window.setTimeout.toString();
                const originalSetInterval = window.setInterval.toString();
                
                // Check for global variables that might be overwritten
                const globalVars = Object.keys(window).filter(key => 
                    !['document', 'window', 'console', 'navigator'].includes(key) &&
                    typeof window[key] !== 'function'
                );
                
                if (globalVars.length > 20) {
                    issues.push(`${globalVars.length} global variables detected - namespace pollution risk`);
                }
                
                return issues;
            });

            jsIssues.forEach(issue => {
                this.addVulnerability({
                    page: pageName,
                    type: 'JAVASCRIPT_SECURITY',
                    severity: 'MEDIUM',
                    description: 'JavaScript security issue detected',
                    impact: 'Potential code injection or namespace pollution',
                    recommendation: 'Follow secure JavaScript coding practices',
                    evidence: issue
                });
            });
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  JavaScript security test failed: ${error.message}`);
        }
    }

    async testThirdPartyDependencies(page, pageName) {
        try {
            const dependencies = await page.evaluate(() => {
                const scripts = Array.from(document.querySelectorAll('script[src]'));
                return scripts.map(script => ({
                    src: script.src,
                    integrity: script.integrity,
                    crossorigin: script.crossOrigin
                }));
            });

            dependencies.forEach(dep => {
                // Check for missing SRI
                if (dep.src.includes('cdn') || dep.src.includes('http')) {
                    if (!dep.integrity) {
                        this.addVulnerability({
                            page: pageName,
                            type: 'MISSING_SRI',
                            severity: 'MEDIUM',
                            description: 'Third-party script lacks Subresource Integrity',
                            impact: 'Risk of compromised external resources',
                            recommendation: 'Add integrity attributes to external scripts',
                            evidence: `Script: ${dep.src}`
                        });
                    }
                }
                
                // Check for HTTP resources on HTTPS pages
                if (dep.src.startsWith('http://')) {
                    this.addVulnerability({
                        page: pageName,
                        type: 'MIXED_CONTENT',
                        severity: 'HIGH',
                        description: 'HTTP resource loaded in HTTPS context',
                        impact: 'Man-in-the-middle attack vulnerability',
                        recommendation: 'Use HTTPS for all external resources',
                        evidence: `Script: ${dep.src}`
                    });
                }
            });
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Third-party dependencies test failed: ${error.message}`);
        }
    }

    async testAuthSecurity(page, pageName) {
        try {
            const authElements = await page.evaluate(() => {
                const forms = Array.from(document.querySelectorAll('form'));
                const passwordInputs = Array.from(document.querySelectorAll('input[type="password"]'));
                const cookies = document.cookie;
                
                return {
                    hasPasswordInputs: passwordInputs.length > 0,
                    hasFormsWithoutCSRF: forms.some(form => 
                        !form.querySelector('input[name*="token"], input[name*="csrf"]')
                    ),
                    cookiesPresent: cookies.length > 0,
                    forms: forms.length
                };
            });

            if (authElements.hasPasswordInputs) {
                // Check for missing autocomplete attributes
                const insecurePasswordFields = await page.$$('input[type="password"]:not([autocomplete])');
                if (insecurePasswordFields.length > 0) {
                    this.addVulnerability({
                        page: pageName,
                        type: 'MISSING_AUTOCOMPLETE',
                        severity: 'LOW',
                        description: 'Password fields missing autocomplete attributes',
                        impact: 'Reduced user security and privacy',
                        recommendation: 'Add appropriate autocomplete attributes',
                        evidence: `${insecurePasswordFields.length} password fields affected`
                    });
                }
            }

            if (authElements.hasFormsWithoutCSRF && authElements.forms > 0) {
                this.addVulnerability({
                    page: pageName,
                    type: 'MISSING_CSRF_PROTECTION',
                    severity: 'HIGH',
                    description: 'Forms lack CSRF protection tokens',
                    impact: 'Cross-Site Request Forgery attacks possible',
                    recommendation: 'Implement CSRF tokens in all forms',
                    evidence: 'No CSRF tokens detected in forms'
                });
            }
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Auth security test failed: ${error.message}`);
        }
    }

    async testErrorHandling(page, pageName) {
        try {
            // Monitor console errors
            const consoleLogs = [];
            page.on('console', msg => {
                if (msg.type() === 'error') {
                    consoleLogs.push(msg.text());
                }
            });

            // Trigger potential errors
            await page.evaluate(() => {
                try {
                    // Try to access non-existent elements
                    document.getElementById('non-existent-element').click();
                } catch (e) {
                    // Expected error
                }
                
                try {
                    // Try to call non-existent function
                    window.nonExistentFunction();
                } catch (e) {
                    // Expected error
                }
            });

            await page.waitForTimeout(1000);

            if (consoleLogs.length > 0) {
                consoleLogs.forEach(error => {
                    if (error.includes('Uncaught') || error.includes('TypeError')) {
                        this.addVulnerability({
                            page: pageName,
                            type: 'UNHANDLED_ERRORS',
                            severity: 'LOW',
                            description: 'Unhandled JavaScript errors detected',
                            impact: 'Information disclosure through error messages',
                            recommendation: 'Implement proper error handling',
                            evidence: error.substring(0, 100)
                        });
                    }
                });
            }
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Error handling test failed: ${error.message}`);
        }
    }

    async testDataExposure(page, pageName) {
        try {
            const exposedData = await page.evaluate(() => {
                const dataAttributes = Array.from(document.querySelectorAll('[data-*]'))
                    .map(el => Array.from(el.attributes)
                        .filter(attr => attr.name.startsWith('data-'))
                        .map(attr => ({ name: attr.name, value: attr.value })))
                    .flat();

                const jsonData = [];
                const scripts = Array.from(document.querySelectorAll('script:not([src])'));
                scripts.forEach(script => {
                    try {
                        const content = script.innerHTML;
                        if (content.includes('{') && content.includes('}')) {
                            const jsonMatches = content.match(/\{[^}]*\}/g);
                            if (jsonMatches) {
                                jsonData.push(...jsonMatches);
                            }
                        }
                    } catch (e) {
                        // Ignore parsing errors
                    }
                });

                return { dataAttributes, jsonData };
            });

            // Check for sensitive data in attributes
            exposedData.dataAttributes.forEach(attr => {
                if (/password|secret|token|key|private/i.test(attr.name) || 
                    /password|secret|token|key|private/i.test(attr.value)) {
                    this.addVulnerability({
                        page: pageName,
                        type: 'DATA_EXPOSURE',
                        severity: 'MEDIUM',
                        description: 'Sensitive data exposed in HTML attributes',
                        impact: 'Information leakage through DOM inspection',
                        recommendation: 'Remove sensitive data from HTML attributes',
                        evidence: `Attribute: ${attr.name}="${attr.value.substring(0, 20)}..."`
                    });
                }
            });

            // Check JSON data for sensitive information
            exposedData.jsonData.forEach((json, index) => {
                if (/password|secret|token|key|private/i.test(json)) {
                    this.addVulnerability({
                        page: pageName,
                        type: 'JSON_DATA_EXPOSURE',
                        severity: 'MEDIUM',
                        description: 'Potentially sensitive data in JSON objects',
                        impact: 'Information leakage through JavaScript objects',
                        recommendation: 'Review and sanitize client-side data objects',
                        evidence: `JSON object ${index + 1}: ${json.substring(0, 50)}...`
                    });
                }
            });
            
        } catch (error) {
            console.log(`   ‚ö†Ô∏è  Data exposure test failed: ${error.message}`);
        }
    }

    addVulnerability(vuln) {
        this.results.vulnerabilities.push({
            ...vuln,
            id: crypto.randomUUID(),
            timestamp: new Date().toISOString()
        });
        
        this.results.summary[vuln.severity.toLowerCase()]++;

        const severityEmoji = {
            'CRITICAL': 'üö®',
            'HIGH': 'üî¥',
            'MEDIUM': 'üü†',
            'LOW': 'üü°',
            'INFO': '‚ÑπÔ∏è'
        };

        console.log(`   ${severityEmoji[vuln.severity]} ${vuln.severity}: ${vuln.description}`);
    }

    async generateSecurityReport() {
        console.log('\nüõ°Ô∏è  SECURITY SCAN SUMMARY');
        console.log('‚ïê'.repeat(60));
        console.log(`üö® Critical: ${this.results.summary.critical}`);
        console.log(`üî¥ High: ${this.results.summary.high}`);
        console.log(`üü† Medium: ${this.results.summary.medium}`);
        console.log(`üü° Low: ${this.results.summary.low}`);
        console.log(`‚ÑπÔ∏è  Info: ${this.results.summary.info}`);
        
        const totalVulns = Object.values(this.results.summary).reduce((a, b) => a + b, 0);
        console.log(`\nüìä Total Issues: ${totalVulns}`);

        // Security score calculation
        const criticalWeight = 10;
        const highWeight = 7;
        const mediumWeight = 4;
        const lowWeight = 1;
        
        const riskScore = (
            this.results.summary.critical * criticalWeight +
            this.results.summary.high * highWeight +
            this.results.summary.medium * mediumWeight +
            this.results.summary.low * lowWeight
        );
        
        const maxPossibleScore = 100;
        const securityScore = Math.max(0, maxPossibleScore - riskScore);
        
        console.log(`üîí Security Score: ${securityScore}/100`);

        // Save detailed report
        const reportPath = './test-screenshots/security-scan-report.json';
        fs.writeFileSync(reportPath, JSON.stringify(this.results, null, 2));
        console.log(`\nüìÑ Detailed report saved: ${reportPath}`);

        // Generate action plan
        this.generateActionPlan();
    }

    generateActionPlan() {
        console.log('\nüéØ SECURITY ACTION PLAN');
        console.log('‚ïê'.repeat(60));

        if (this.results.summary.critical > 0) {
            console.log('üö® IMMEDIATE ACTION REQUIRED:');
            console.log('   ‚Ä¢ Fix all CRITICAL vulnerabilities immediately');
            console.log('   ‚Ä¢ Consider taking affected systems offline');
        }

        if (this.results.summary.high > 0) {
            console.log('üî¥ HIGH PRIORITY (Fix within 24-48 hours):');
            this.results.vulnerabilities
                .filter(v => v.severity === 'HIGH')
                .slice(0, 3)
                .forEach(v => console.log(`   ‚Ä¢ ${v.description}`));
        }

        if (this.results.summary.medium > 0) {
            console.log('üü† MEDIUM PRIORITY (Fix within 1-2 weeks):');
            console.log(`   ‚Ä¢ ${this.results.summary.medium} medium-risk issues identified`);
        }

        if (this.results.summary.low > 0) {
            console.log('üü° LOW PRIORITY (Fix in next maintenance cycle):');
            console.log(`   ‚Ä¢ ${this.results.summary.low} low-risk issues identified`);
        }

        console.log('\nüí° GENERAL RECOMMENDATIONS:');
        console.log('   ‚Ä¢ Implement Content Security Policy');
        console.log('   ‚Ä¢ Add input validation and sanitization');
        console.log('   ‚Ä¢ Use HTTPS for all external resources');
        console.log('   ‚Ä¢ Regular security scanning and code reviews');
        console.log('   ‚Ä¢ Employee security awareness training');
    }
}

// Run the security scan
async function runSecurityScan() {
    const scanner = new SecurityScanner();
    await scanner.runSecurityScan();
}

if (require.main === module) {
    runSecurityScan().catch(console.error);
}

module.exports = SecurityScanner;