{
  "timestamp": "2025-07-26T16:42:50.551Z",
  "issues": [
    {
      "page": "Enhanced 3D Professional Analysis",
      "issues": [
        {
          "text": "// Enhanced facility data with electrical systems\n        const facilityData = {\n            newRooms: [\n                { id: 'Flower_140', area: 140, dimensions: [66, 19, 12], fixtures: 63, sqft: 1254, circuits: [1,2,3,4,5,6,7,8] },\n                { id: 'Flower_141', area: 141, dimensions: [66, 19, 12], fixtures: 63, sqft: 1254, circuits: [9,10,11,12,13,14,15,16] },\n                { id: 'Flower_142', area: 142, dimensions: [66, 19, 12], fixtures: 63, sqft: 1254, circuits: [17,18,19,20,21,22,23,24] },\n                { id: 'Flower_143', area: 143, dimensions: [66, 19, 12], fixtures: 63, sqft: 1254, circuits: [25,26,27,28,29,30,31,32] },\n                { id: 'Flower_144', area: 144, dimensions: [66, 19, 12], fixtures: 63, sqft: 1254, circuits: [33,34,35,36,37,38,39,40] },\n                { id: 'Flower_145', area: 145, dimensions: [66, 19, 12], fixtures: 63, sqft: 1254, circuits: [41,42,43,44,45,46,47,48] },\n                { id: 'Flower_146', area: 146, dimensions: [66, 19, 12], fixtures: 63, sqft: 1254, circuits: [49,50,51,52,53,54,55] }\n            ],\n            existingRooms: [\n                { id: 'Flowering_3', area: 134, dimensions: [28, 25, 12], fixtures: 36, sqft: 700, circuits: [56,57,58,59] },\n                { id: 'Flowering_4', area: 133, dimensions: [28, 25, 12], fixtures: 36, sqft: 700, circuits: [60,61,62,63] },\n                { id: 'Flowering_5', area: 132, dimensions: [28, 25, 12], fixtures: 36, sqft: 700, circuits: [64,65,66,67] },\n                { id: 'Flowering_6', area: 131, dimensions: [28, 25, 12], fixtures: 36, sqft: 700, circuits: [68,69,70,71] },\n                { id: 'Flowering_7', area: 130, dimensions: [28, 25, 12], fixtures: 36, sqft: 700, circuits: [72,73,74,75] },\n                { id: 'Flowering_8', area: 129, dimensions: [40, 35, 12], fixtures: 72, sqft: 1400, circuits: [76,77,78,79,80,81,82,83] },\n                { id: 'Flowering_9', area: 127, dimensions: [40, 35, 12], fixtures: 72, sqft: 1400, circuits: [84,85,86,87,88,89,90] }\n            ]\n        };\n        \n        // Three.js setup with enhanced features\n        let scene, camera, renderer;\n        let lightingVisible = true;\n        let heatmapVisible = false;\n        let electricalVisible = false;\n        let circuitsVisible = false;\n        let fixtureLabelsVisible = false;\n        let lightBeamsVisible = false;\n        let panelsVisible = false;\n        let loadAnalysisVisible = false;\n        \n        let selectedRoom = null;\n        let selectedFixture = null;\n        let roomMeshes = [];\n        let fixtureMeshes = [];\n        let electricalMeshes = [];\n        let circuitMeshes = [];\n        let heatmapMeshes = [];\n        let labelMeshes = [];\n        let lightBeamMeshes = [];\n        let panelMeshes = [];\n        \n        // Camera control variables\n        let cameraTheta = 0, cameraPhi = 0, cameraRadius = 100;\n        let mouseDown = false, mouseX = 0, mouseY = 0;\n        \n        // Performance monitoring\n        let frameCount = 0;\n        let lastTime = performance.now();\n        \n        function initThreeJS() {\n            const container = document.getElementById('threejs-container');\n            \n            // Scene setup\n            scene = new THREE.Scene();\n            scene.background = new THREE.Color(0x0a0a0a);\n            scene.fog = new THREE.Fog(0x0a0a0a, 50, 300);\n            \n            // Camera setup\n            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);\n            camera.position.set(80, 60, 80);\n            camera.lookAt(0, 0, 0);\n            \n            // Renderer setup with enhanced settings\n            renderer = new THREE.WebGLRenderer({ \n                antialias: true,\n                powerPreference: \"high-performance\"\n            });\n            renderer.setSize(container.clientWidth, container.clientHeight);\n            renderer.shadowMap.enabled = true;\n            renderer.shadowMap.type = THREE.PCFSoftShadowMap;\n            renderer.outputEncoding = THREE.sRGBEncoding;\n            renderer.toneMapping = THREE.ACESFilmicToneMapping;\n            renderer.toneMappingExposure = 1.2;\n            container.appendChild(renderer.domElement);\n            \n            // Enhanced lighting setup\n            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);\n            scene.add(ambientLight);\n            \n            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);\n            directionalLight.position.set(100, 100, 50);\n            directionalLight.castShadow = true;\n            directionalLight.shadow.mapSize.width = 4096;\n            directionalLight.shadow.mapSize.height = 4096;\n            directionalLight.shadow.camera.near = 0.5;\n            directionalLight.shadow.camera.far = 500;\n            directionalLight.shadow.camera.left = -150;\n            directionalLight.shadow.camera.right = 150;\n            directionalLight.shadow.camera.top = 150;\n            directionalLight.shadow.camera.bottom = -150;\n            scene.add(directionalLight);\n            \n            // Additional fill lighting\n            const fillLight = new THREE.DirectionalLight(0x4a90e2, 0.3);\n            fillLight.position.set(-50, 30, -50);\n            scene.add(fillLight);\n            \n            // Mouse controls\n            setupEnhancedMouseControls();\n            \n            // Mouse interaction for fixture selection\n            setupMouseInteraction();\n            \n            // Build complete facility\n            buildEnhancedFacility();\n            \n            // Start render loop\n            animate();\n            \n            // Update status\n            updateStatus('âœ… Enhanced 3D facility model loaded - 765 VYPR 2p fixtures with electrical systems');\n            \n            // Initialize circuit monitor\n            initializeCircuitMonitor();\n        }\n        \n        function setupEnhancedMouseControls() {\n            const canvas = renderer.domElement;\n            \n            canvas.addEventListener('mousedown', (event) => {\n                mouseDown = true;\n                mouseX = event.clientX;\n                mouseY = event.clientY;\n            });\n            \n            canvas.addEventListener('mouseup', () => {\n                mouseDown = false;\n            });\n            \n            canvas.addEventListener('mousemove', (event) => {\n                if (!mouseDown) return;\n                \n                const deltaX = event.clientX - mouseX;\n                const deltaY = event.clientY - mouseY;\n                \n                if (event.shiftKey) {\n                    // Pan camera\n                    const panX = deltaX * 0.01;\n                    const panY = deltaY * 0.01;\n                    \n                    const right = new THREE.Vector3();\n                    const up = new THREE.Vector3();\n                    camera.getWorldDirection(right);\n                    right.cross(camera.up);\n                    up.copy(camera.up);\n                    \n                    camera.position.add(right.multiplyScalar(-panX));\n                    camera.position.add(up.multiplyScalar(panY));\n                } else {\n                    // Rotate camera\n                    cameraTheta -= deltaX * 0.01;\n                    cameraPhi += deltaY * 0.01;\n                    cameraPhi = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, cameraPhi));\n                    \n                    updateCameraPosition();\n                }\n                \n                mouseX = event.clientX;\n                mouseY = event.clientY;\n            });\n            \n            canvas.addEventListener('wheel', (event) => {\n                cameraRadius += event.deltaY * 0.02;\n                cameraRadius = Math.max(20, Math.min(200, cameraRadius));\n                updateCameraPosition();\n                event.preventDefault();\n            });\n        }\n        \n        function updateCameraPosition() {\n            camera.position.x = cameraRadius * Math.cos(cameraPhi) * Math.cos(cameraTheta);\n            camera.position.y = cameraRadius * Math.sin(cameraPhi);\n            camera.position.z = cameraRadius * Math.cos(cameraPhi) * Math.sin(cameraTheta);\n            camera.lookAt(0, 0, 0);\n        }\n        \n        function setupMouseInteraction() {\n            const raycaster = new THREE.Raycaster();\n            const mouse = new THREE.Vector2();\n            \n            renderer.domElement.addEventListener('click', (event) => {\n                if (mouseDown) return; // Ignore clicks during camera movement\n                \n                const rect = renderer.domElement.getBoundingClientRect();\n                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;\n                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;\n                \n                raycaster.setFromCamera(mouse, camera);\n                \n                // Check for fixture intersections\n                const intersects = raycaster.intersectObjects(fixtureMeshes);\n                if (intersects.length > 0) {\n                    selectFixture(intersects[0].object);\n                    return;\n                }\n                \n                // Check for room intersections\n                const roomIntersects = raycaster.intersectObjects(roomMeshes.map(r => r.floor));\n                if (roomIntersects.length > 0) {\n                    const roomData = roomMeshes.find(r => r.floor === roomIntersects[0].object);\n                    if (roomData) {\n                        selectRoom(roomData.room);\n                    }\n                }\n            });\n        }\n        \n        function buildEnhancedFacility() {\n            // Build new addition rooms with enhanced details\n            let offsetX = 0;\n            facilityData.newRooms.forEach((room, index) => {\n                const roomGroup = createEnhancedRoom(room, 0x2196F3, offsetX, 0, 'new');\n                roomMeshes.push({ ...roomGroup, room, type: 'new' });\n                createEnhancedFixtures(room, offsetX, 0);\n                createElectricalInfrastructure(room, offsetX, 0);\n                offsetX += room.dimensions[0] + 3; // 3ft spacing between rooms\n            });\n            \n            // Build existing rooms with enhanced details\n            offsetX = 0;\n            let offsetZ = -50;\n            facilityData.existingRooms.forEach((room, index) => {\n                const roomGroup = createEnhancedRoom(room, 0x4CAF50, offsetX, offsetZ, 'existing');\n                roomMeshes.push({ ...roomGroup, room, type: 'existing' });\n                createEnhancedFixtures(room, offsetX, offsetZ);\n                createElectricalInfrastructure(room, offsetX, offsetZ);\n                \n                offsetX += room.dimensions[0] + 3;\n                if (index === 4) { // Start new row after 5 rooms\n                    offsetX = 0;\n                    offsetZ -= room.dimensions[1] + 3;\n                }\n            });\n            \n            // Add enhanced ground plane with grid\n            createEnhancedGroundPlane();\n            \n            // Create electrical panels\n            createElectricalPanels();\n            \n            // Update object count\n            updatePerformanceStats();\n        }\n        \n        function createEnhancedRoom(room, color, offsetX, offsetZ, type) {\n            const [length, width, height] = room.dimensions;\n            \n            // Enhanced room materials\n            const wallMaterial = new THREE.MeshPhongMaterial({ \n                color: color,\n                transparent: true,\n                opacity: 0.25,\n                side: THREE.DoubleSide\n            });\n            \n            const floorMaterial = new THREE.MeshPhongMaterial({ \n                color: color,\n                transparent: true,\n                opacity: 0.4,\n                roughness: 0.8,\n                metalness: 0.1\n            });\n            \n            // Floor with enhanced detail\n            const floorGeometry = new THREE.PlaneGeometry(length, width);\n            const floor = new THREE.Mesh(floorGeometry, floorMaterial);\n            floor.rotation.x = -Math.PI / 2;\n            floor.position.set(offsetX + length/2, 0, offsetZ + width/2);\n            floor.receiveShadow = true;\n            floor.userData = { room: room.id, type: 'floor' };\n            scene.add(floor);\n            \n            // Walls with enhanced geometry\n            const wallGroup = new THREE.Group();\n            \n            // Create detailed walls with texture\n            const walls = [\n                { pos: [offsetX + length/2, height/2, offsetZ], rot: [0, 0, 0], size: [length, height] },\n                { pos: [offsetX + length/2, height/2, offsetZ + width], rot: [0, Math.PI, 0], size: [length, height] },\n                { pos: [offsetX, height/2, offsetZ + width/2], rot: [0, Math.PI/2, 0], size: [width, height] },\n                { pos: [offsetX + length, height/2, offsetZ + width/2], rot: [0, -Math.PI/2, 0], size: [width, height] }\n            ];\n            \n            walls.forEach(wall => {\n                const wallGeometry = new THREE.PlaneGeometry(wall.size[0], wall.size[1]);\n                const wallMesh = new THREE.Mesh(wallGeometry, wallMaterial);\n                wallMesh.position.set(...wall.pos);\n                wallMesh.rotation.set(...wall.rot);\n                wallMesh.castShadow = true;\n                wallGroup.add(wallMesh);\n            });\n            \n            scene.add(wallGroup);\n            \n            // Enhanced room label with better typography\n            const label = createRoomLabel(room, offsetX + length/2, height + 2, offsetZ + width/2);\n            scene.add(label);\n            \n            return { floor, wallGroup, label, room };\n        }\n        \n        function createRoomLabel(room, x, y, z) {\n            const canvas = document.createElement('canvas');\n            const context = canvas.getContext('2d');\n            canvas.width = 512;\n            canvas.height = 128;\n            \n            // Clear background\n            context.clearRect(0, 0, 512, 128);\n            \n            // Draw background\n            context.fillStyle = 'rgba(0, 0, 0, 0.8)';\n            context.roundRect(10, 10, 492, 108, 10);\n            context.fill();\n            \n            // Draw border\n            context.strokeStyle = '#64b5f6';\n            context.lineWidth = 2;\n            context.roundRect(10, 10, 492, 108, 10);\n            context.stroke();\n            \n            // Draw text\n            context.fillStyle = '#ffffff';\n            context.font = 'Bold 28px Arial';\n            context.textAlign = 'center';\n            context.fillText(room.id, 256, 45);\n            \n            context.fillStyle = '#64b5f6';\n            context.font = '20px Arial';\n            context.fillText(`${room.fixtures} VYPR 2p Fixtures`, 256, 70);\n            \n            context.fillStyle = '#888888';\n            context.font = '16px Arial';\n            context.fillText(`${room.sqft} sq ft`, 256, 95);\n            \n            const labelTexture = new THREE.CanvasTexture(canvas);\n            const labelMaterial = new THREE.MeshBasicMaterial({ \n                map: labelTexture,\n                transparent: true,\n                alphaTest: 0.1\n            });\n            const labelGeometry = new THREE.PlaneGeometry(12, 3);\n            const label = new THREE.Mesh(labelGeometry, labelMaterial);\n            label.position.set(x, y, z);\n            \n            return label;\n        }\n        \n        function createEnhancedFixtures(room, offsetX, offsetZ) {\n            const [length, width] = room.dimensions;\n            const fixtures = room.fixtures;\n            \n            // Calculate enhanced grid layout\n            let gridX, gridZ;\n            if (room.id.includes('Flower_')) {\n                gridX = 15; gridZ = 4; // New addition rooms\n            } else if (room.fixtures === 72) {\n                gridX = 9; gridZ = 8; // Large existing rooms\n            } else {\n                gridX = 6; gridZ = 6; // Small existing rooms\n            }\n            \n            const spacing = 4.5; // feet\n            const startX = offsetX + (length - (gridX - 1) * spacing) / 2;\n            const startZ = offsetZ + (width - (gridZ - 1) * spacing) / 2;\n            \n            // Enhanced fixture geometry and materials\n            const fixtureGeometry = new THREE.BoxGeometry(3.5, 0.4, 3.5);\n            const fixtureMaterial = new THREE.MeshPhongMaterial({ \n                color: 0xFFD700,\n                emissive: 0xFFD700,\n                emissiveIntensity: 0.4,\n                roughness: 0.3,\n                metalness: 0.7\n            });\n            \n            // Create fixtures with enhanced features\n            let fixtureIndex = 0;\n            for (let x = 0; x < gridX; x++) {\n                for (let z = 0; z < gridZ; z++) {\n                    if (fixtureIndex >= fixtures) break;\n                    \n                    const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);\n                    const posX = startX + x * spacing;\n                    const posZ = startZ + z * spacing;\n                    \n                    fixture.position.set(posX, 8, posZ);\n                    fixture.castShadow = true;\n                    fixture.userData = { \n                        room: room.id, \n                        type: 'vypr2p',\n                        fixtureId: `${room.id}_F${Math.floor(fixtureIndex/gridZ) + 1}-${(fixtureIndex%gridZ) + 1}`,\n                        circuit: room.circuits[Math.floor(fixtureIndex / 8)],\n                        wattage: 645,\n                        ppf: 1742,\n                        position: { x: posX, y: 8, z: posZ }\n                    };\n                    scene.add(fixture);\n                    fixtureMeshes.push(fixture);\n                    \n                    // Create light beam effect\n                    if (lightBeamsVisible) {\n                        createLightBeam(fixture);\n                    }\n                    \n                    // Create PPFD heatmap zone\n                    if (heatmapVisible) {\n                        createHeatmapZone(fixture);\n                    }\n                    \n                    fixtureIndex++;\n                }\n            }\n        }\n        \n        function createLightBeam(fixture) {\n            const lightGeometry = new THREE.ConeGeometry(4, 8, 12);\n            const lightMaterial = new THREE.MeshBasicMaterial({\n                color: 0xffffaa,\n                transparent: true,\n                opacity: 0.15,\n                side: THREE.DoubleSide\n            });\n            const lightCone = new THREE.Mesh(lightGeometry, lightMaterial);\n            lightCone.position.copy(fixture.position);\n            lightCone.position.y = 4;\n            lightCone.rotation.x = Math.PI;\n            lightCone.userData = { type: 'lightBeam', parent: fixture };\n            scene.add(lightCone);\n            lightBeamMeshes.push(lightCone);\n        }\n        \n        function createHeatmapZone(fixture) {\n            // Calculate PPFD intensity at canopy level (3 feet below fixture)\n            const distance = 5; // 8ft - 3ft = 5ft distance to canopy\n            const ppfdAtCanopy = calculatePPFDAtDistance(fixture.userData.ppf, distance);\n            \n            // Color based on PPFD intensity\n            let color;\n            if (ppfdAtCanopy < 600) color = 0x4CAF50;        // Green - Low\n            else if (ppfdAtCanopy < 750) color = 0x8BC34A;   // Light Green\n            else if (ppfdAtCanopy < 850) color = 0xFFEB3B;   // Yellow - Optimal\n            else if (ppfdAtCanopy < 950) color = 0xFF9800;   // Orange - High\n            else color = 0xF44336;                           // Red - Very High\n            \n            const heatmapGeometry = new THREE.CircleGeometry(3, 16);\n            const heatmapMaterial = new THREE.MeshBasicMaterial({\n                color: color,\n                transparent: true,\n                opacity: 0.6,\n                side: THREE.DoubleSide\n            });\n            const heatmapZone = new THREE.Mesh(heatmapGeometry, heatmapMaterial);\n            heatmapZone.position.copy(fixture.position);\n            heatmapZone.position.y = 3; // Canopy level\n            heatmapZone.rotation.x = -Math.PI / 2;\n            heatmapZone.userData = { type: 'heatmap', parent: fixture, ppfd: ppfdAtCanopy };\n            heatmapZone.visible = heatmapVisible;\n            scene.add(heatmapZone);\n            heatmapMeshes.push(heatmapZone);\n        }\n        \n        function calculatePPFDAtDistance(ppf, distance) {\n            // Simplified PPFD calculation using inverse square law\n            const referenceDistance = 3; // feet\n            const referencePPFD = 900; // Î¼mol/mÂ²/s at 3 feet\n            return referencePPFD * Math.pow(referenceDistance / distance, 2);\n        }\n        \n        function createElectricalInfrastructure(room, offsetX, offsetZ) {\n            const [length, width] = room.dimensions;\n            \n            // Create conduit routing\n            room.circuits.forEach((circuitId, index) => {\n                createConduitRun(room, offsetX, offsetZ, circuitId, index);\n            });\n        }\n        \n        function createConduitRun(room, offsetX, offsetZ, circuitId, index) {\n            const [length, width] = room.dimensions;\n            \n            // Conduit material\n            const conduitMaterial = new THREE.MeshPhongMaterial({ \n                color: 0x9C27B0,\n                metalness: 0.8,\n                roughness: 0.2\n            });\n            \n            // Main conduit run along ceiling\n            const conduitGeometry = new THREE.CylinderGeometry(0.1, 0.1, length * 0.8);\n            const conduit = new THREE.Mesh(conduitGeometry, conduitMaterial);\n            conduit.position.set(\n                offsetX + length/2,\n                11, // Above fixtures\n                offsetZ + width/2 + (index - room.circuits.length/2) * 2\n            );\n            conduit.rotation.z = Math.PI / 2;\n            conduit.userData = { type: 'conduit', circuit: circuitId, room: room.id };\n            conduit.visible = electricalVisible;\n            scene.add(conduit);\n            electricalMeshes.push(conduit);\n            \n            // Junction boxes\n            const junctionGeometry = new THREE.BoxGeometry(0.8, 0.8, 0.3);\n            const junctionMaterial = new THREE.MeshPhongMaterial({ color: 0x666666 });\n            const junction = new THREE.Mesh(junctionGeometry, junctionMaterial);\n            junction.position.set(\n                offsetX + 5 + index * 8,\n                11,\n                offsetZ + width/2\n            );\n            junction.userData = { type: 'junction', circuit: circuitId };\n            junction.visible = electricalVisible;\n            scene.add(junction);\n            electricalMeshes.push(junction);\n        }\n        \n        function createElectricalPanels() {\n            // Main electrical panels for new addition\n            const panelGeometry = new THREE.BoxGeometry(3, 6, 1);\n            const panelMaterial = new THREE.MeshPhongMaterial({ \n                color: 0x333333,\n                metalness: 0.6,\n                roughness: 0.4\n            });\n            \n            // Panel for new addition\n            const newPanel = new THREE.Mesh(panelGeometry, panelMaterial);\n            newPanel.position.set(250, 5, -10);\n            newPanel.userData = { type: 'panel', name: 'New Addition Main Panel', circuits: '1-55' };\n            newPanel.visible = panelsVisible;\n            scene.add(newPanel);\n            panelMeshes.push(newPanel);\n            \n            // Panel for existing building\n            const existingPanel = new THREE.Mesh(panelGeometry, panelMaterial);\n            existingPanel.position.set(50, 5, -80);\n            existingPanel.userData = { type: 'panel', name: 'Existing Building Panel', circuits: '56-90' };\n            existingPanel.visible = panelsVisible;\n            scene.add(existingPanel);\n            panelMeshes.push(existingPanel);\n        }\n        \n        function createEnhancedGroundPlane() {\n            // Main ground plane\n            const groundGeometry = new THREE.PlaneGeometry(600, 400);\n            const groundMaterial = new THREE.MeshLambertMaterial({ \n                color: 0x2a2a2a,\n                transparent: true,\n                opacity: 0.8 \n            });\n            const ground = new THREE.Mesh(groundGeometry, groundMaterial);\n            ground.rotation.x = -Math.PI / 2;\n            ground.position.y = -0.5;\n            ground.receiveShadow = true;\n            scene.add(ground);\n            \n            // Grid lines\n            const gridHelper = new THREE.GridHelper(400, 40, 0x444444, 0x222222);\n            gridHelper.position.y = -0.4;\n            scene.add(gridHelper);\n        }\n        \n        function initializeCircuitMonitor() {\n            const circuitMonitor = document.getElementById('circuit-monitor');\n            circuitMonitor.innerHTML = '';\n            \n            for (let i = 1; i <= 20; i++) { // Show first 20 circuits\n                const circuitBox = document.createElement('div');\n                circuitBox.className = 'circuit-box';\n                circuitBox.innerHTML = `C${i}<br>5.5kW`;\n                circuitBox.onclick = () => highlightCircuit(i);\n                circuitMonitor.appendChild(circuitBox);\n            }\n        }\n        \n        function highlightCircuit(circuitId) {\n            // Reset all circuit boxes\n            document.querySelectorAll('.circuit-box').forEach(box => {\n                box.classList.remove('active');\n            });\n            \n            // Highlight selected circuit\n            document.querySelectorAll('.circuit-box')[circuitId - 1]?.classList.add('active');\n            \n            // Highlight fixtures on this circuit\n            fixtureMeshes.forEach(fixture => {\n                if (fixture.userData.circuit === circuitId) {\n                    fixture.material.emissiveIntensity = 0.8;\n                    fixture.material.color.setHex(0x00FF00);\n                } else {\n                    fixture.material.emissiveIntensity = 0.4;\n                    fixture.material.color.setHex(0xFFD700);\n                }\n            });\n            \n            updateStatus(`âš¡ Circuit ${circuitId} highlighted - showing connected fixtures`);\n        }\n        \n        function selectFixture(fixtureMesh) {\n            selectedFixture = fixtureMesh;\n            \n            // Reset all fixture materials\n            fixtureMeshes.forEach(f => {\n                f.material.emissiveIntensity = 0.4;\n                f.material.color.setHex(0xFFD700);\n            });\n            \n            // Highlight selected fixture\n            fixtureMesh.material.emissiveIntensity = 1.0;\n            fixtureMesh.material.color.setHex(0x00FF00);\n            \n            // Update fixture details panel\n            updateFixtureDetails(fixtureMesh);\n            \n            // Switch to fixture tab\n            showTab('fixture');\n            \n            updateStatus(`ðŸ’¡ Selected fixture: ${fixtureMesh.userData.fixtureId}`);\n        }\n        \n        function updateFixtureDetails(fixture) {\n            const detailsPanel = document.getElementById('fixture-details');\n            const userData = fixture.userData;\n            \n            detailsPanel.innerHTML = `\n                <div class=\"fixture-info\">\n                    <h4>ðŸ’¡ ${userData.fixtureId}</h4>\n                    <div class=\"fixture-detail\">\n                        <span class=\"label\">Model:</span>\n                        <span class=\"value\">Fluence VYPR 2p</span>\n                    </div>\n                    <div class=\"fixture-detail\">\n                        <span class=\"label\">Room:</span>\n                        <span class=\"value\">${userData.room}</span>\n                    </div>\n                    <div class=\"fixture-detail\">\n                        <span class=\"label\">Circuit:</span>\n                        <span class=\"value\">Circuit ${userData.circuit}</span>\n                    </div>\n                    <div class=\"fixture-detail\">\n                        <span class=\"label\">Power:</span>\n                        <span class=\"value\">${userData.wattage}W</span>\n                    </div>\n                    <div class=\"fixture-detail\">\n                        <span class=\"label\">PPF Output:</span>\n                        <span class=\"value\">${userData.ppf} Î¼mol/s</span>\n                    </div>\n                    <div class=\"fixture-detail\">\n                        <span class=\"label\">Position:</span>\n                        <span class=\"value\">X: ${userData.position.x.toFixed(1)}' Y: ${userData.position.y}' Z: ${userData.position.z.toFixed(1)}'</span>\n                    </div>\n                    <div class=\"fixture-detail\">\n                        <span class=\"label\">PPFD at Canopy:</span>\n                        <span class=\"value\">${calculatePPFDAtDistance(userData.ppf, 5).toFixed(0)} Î¼mol/mÂ²/s</span>\n                    </div>\n                </div>\n                \n                <div style=\"margin-top: 1rem;\">\n                    <h4 style=\"color: #64b5f6; margin-bottom: 0.5rem;\">Performance Metrics</h4>\n                    <div style=\"font-size: 0.8rem; color: #ccc;\">\n                        <div style=\"margin: 0.25rem 0;\">â€¢ Efficacy: 2.7 Î¼mol/J</div>\n                        <div style=\"margin: 0.25rem 0;\">â€¢ Spectrum: PhysioSpec BROAD R4</div>\n                        <div style=\"margin: 0.25rem 0;\">â€¢ Dimming: 0-100% (0-10V)</div>\n                        <div style=\"margin: 0.25rem 0;\">â€¢ Lifespan: 54,000 hours L90</div>\n                        <div style=\"margin: 0.25rem 0;\">â€¢ Warranty: 5 years</div>\n                    </div>\n                </div>\n            `;\n        }\n        \n        function selectRoom(room) {\n            selectedRoom = room;\n            \n            // Update room list selection\n            document.querySelectorAll('.room-item').forEach(item => {\n                item.classList.remove('selected');\n                if (item.dataset.roomId === room.id) {\n                    item.classList.add('selected');\n                }\n            });\n            \n            updateStatus(`ðŸ¢ Selected room: ${room.id} - ${room.fixtures} fixtures`);\n        }\n        \n        function animate() {\n            requestAnimationFrame(animate);\n            \n            // Update fixture animations\n            const time = Date.now() * 0.001;\n            fixtureMeshes.forEach((fixture, index) => {\n                if (fixture.material && lightingVisible) {\n                    fixture.material.emissiveIntensity = 0.4 + Math.sin(time + index * 0.1) * 0.1;\n                }\n            });\n            \n            // Update performance stats\n            frameCount++;\n            const currentTime = performance.now();\n            if (currentTime - lastTime >= 1000) {\n                updatePerformanceStats();\n                lastTime = currentTime;\n                frameCount = 0;\n            }\n            \n            renderer.render(scene, camera);\n        }\n        \n        function updatePerformanceStats() {\n            const stats = document.getElementById('performance-stats');\n            const memoryInfo = performance.memory ? \n                `${(performance.memory.usedJSHeapSize / 1048576).toFixed(1)}MB` : \n                'N/A';\n            \n            stats.textContent = `FPS: ${frameCount} | Objects: ${scene.children.length} | Memory: ${memoryInfo}`;\n        }\n        \n        function updateStatus(message) {\n            document.getElementById('status-text').textContent = message;\n        }\n        \n        // Control functions\n        function setView(viewType) {\n            // Update button states\n            document.querySelectorAll('.control-button').forEach(btn => btn.classList.remove('active'));\n            event.target.classList.add('active');\n            \n            switch(viewType) {\n                case 'overview':\n                    cameraTheta = 0.5;\n                    cameraPhi = 0.3;\n                    cameraRadius = 120;\n                    updateCameraPosition();\n                    break;\n                case 'newRooms':\n                    cameraTheta = 0;\n                    cameraPhi = 0.2;\n                    cameraRadius = 80;\n                    updateCameraPosition();\n                    break;\n                case 'existingRooms':\n                    cameraTheta = 0;\n                    cameraPhi = 0.2;\n                    cameraRadius = 60;\n                    camera.position.set(50, 30, -40);\n                    camera.lookAt(50, 0, -60);\n                    break;\n                case 'electrical':\n                    electricalVisible = true;\n                    circuitsVisible = true;\n                    panelsVisible = true;\n                    updateElectricalVisibility();\n                    break;\n            }\n            \n            updateStatus(`ðŸŽ¯ View changed to: ${viewType}`);\n        }\n        \n        function toggleLighting() {\n            lightingVisible = !lightingVisible;\n            event.target.classList.toggle('active');\n            \n            fixtureMeshes.forEach(fixture => {\n                fixture.visible = lightingVisible;\n            });\n            \n            updateStatus(`ðŸ’¡ Lighting ${lightingVisible ? 'enabled' : 'disabled'}`);\n        }\n        \n        function toggleHeatmap() {\n            heatmapVisible = !heatmapVisible;\n            event.target.classList.toggle('active');\n            \n            if (heatmapVisible && heatmapMeshes.length === 0) {\n                // Create heatmap zones if they don't exist\n                fixtureMeshes.forEach(fixture => {\n                    createHeatmapZone(fixture);\n                });\n            }\n            \n            heatmapMeshes.forEach(heatmap => {\n                heatmap.visible = heatmapVisible;\n            });\n            \n            document.getElementById('heatmap-legend').style.display = heatmapVisible ? 'block' : 'none';\n            \n            updateStatus(`ðŸ”¥ PPFD heatmap ${heatmapVisible ? 'enabled' : 'disabled'}`);\n        }\n        \n        function toggleElectrical() {\n            electricalVisible = !electricalVisible;\n            event.target.classList.toggle('active');\n            updateElectricalVisibility();\n            updateStatus(`ðŸ”Œ Electrical systems ${electricalVisible ? 'visible' : 'hidden'}`);\n        }\n        \n        function toggleCircuits() {\n            circuitsVisible = !circuitsVisible;\n            event.target.classList.toggle('active');\n            updateElectricalVisibility();\n            updateStatus(`âš¡ Circuit paths ${circuitsVisible ? 'visible' : 'hidden'}`);\n        }\n        \n        function togglePanels() {\n            panelsVisible = !panelsVisible;\n            event.target.classList.toggle('active');\n            panelMeshes.forEach(panel => {\n                panel.visible = panelsVisible;\n            });\n            updateStatus(`ðŸ“‹ Electrical panels ${panelsVisible ? 'visible' : 'hidden'}`);\n        }\n        \n        function toggleFixtureLabels() {\n            fixtureLabelsVisible = !fixtureLabelsVisible;\n            event.target.classList.toggle('active');\n            // TODO: Implement fixture labels\n            updateStatus(`ðŸ·ï¸ Fixture labels ${fixtureLabelsVisible ? 'enabled' : 'disabled'}`);\n        }\n        \n        function toggleLightBeams() {\n            lightBeamsVisible = !lightBeamsVisible;\n            event.target.classList.toggle('active');\n            \n            if (lightBeamsVisible && lightBeamMeshes.length === 0) {\n                fixtureMeshes.forEach(fixture => {\n                    createLightBeam(fixture);\n                });\n            }\n            \n            lightBeamMeshes.forEach(beam => {\n                beam.visible = lightBeamsVisible;\n            });\n            \n            updateStatus(`ðŸ“¡ Light coverage ${lightBeamsVisible ? 'visible' : 'hidden'}`);\n        }\n        \n        function toggleLoadAnalysis() {\n            loadAnalysisVisible = !loadAnalysisVisible;\n            event.target.classList.toggle('active');\n            // TODO: Implement load analysis visualization\n            updateStatus(`ðŸ“Š Load analysis ${loadAnalysisVisible ? 'enabled' : 'disabled'}`);\n        }\n        \n        function updateElectricalVisibility() {\n            electricalMeshes.forEach(mesh => {\n                mesh.visible = electricalVisible;\n            });\n            \n            circuitMeshes.forEach(mesh => {\n                mesh.visible = circuitsVisible;\n            });\n        }\n        \n        function showTab(tabName) {\n            // Update tab buttons\n            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));\n            event.target.classList.add('active');\n            \n            // Update tab content\n            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));\n            document.getElementById(tabName + '-tab').classList.add('active');\n            \n            if (tabName === 'rooms') {\n                populateRoomList();\n            }\n        }\n        \n        function populateRoomList() {\n            const roomList = document.getElementById('room-list');\n            roomList.innerHTML = '';\n            \n            // Add new rooms\n            facilityData.newRooms.forEach(room => {\n                const roomItem = createRoomItem(room, 'new');\n                roomList.appendChild(roomItem);\n            });\n            \n            // Add existing rooms\n            facilityData.existingRooms.forEach(room => {\n                const roomItem = createRoomItem(room, 'existing');\n                roomList.appendChild(roomItem);\n            });\n        }\n        \n        function createRoomItem(room, type) {\n            const item = document.createElement('div');\n            item.className = `room-item ${type}`;\n            item.dataset.roomId = room.id;\n            item.innerHTML = `\n                <div>\n                    <div class=\"room-name\">${room.id}</div>\n                    <div class=\"room-stats\">${room.dimensions[0]}' Ã— ${room.dimensions[1]}' â€¢ ${room.fixtures} fixtures</div>\n                </div>\n                <div class=\"room-stats\">\n                    <div>${room.sqft} sq ft</div>\n                    <div style=\"color: #64b5f6;\">${room.circuits.length} circuits</div>\n                </div>\n            `;\n            \n            item.addEventListener('click', () => {\n                selectRoom(room);\n            });\n            \n            return item;\n        }\n        \n        function handleResize() {\n            const container = document.getElementById('threejs-container');\n            camera.aspect = container.clientWidth / container.clientHeight;\n            camera.updateProjectionMatrix();\n            renderer.setSize(container.clientWidth, container.clientHeight);\n        }\n        \n        // Initialize when page loads\n        window.addEventListener('load', () => {\n            initThreeJS();\n            populateRoomList();\n        });\n        \n        window.addEventListener('resize', handleResize);",
          "element": "SCRIPT",
          "class": "",
          "id": "",
          "path": "html > body > script"
        }
      ]
    },
    {
      "page": "White Label Report Builder",
      "issues": [
        {
          "text": "// Report customization functions\n        let editingSection = null;\n        let currentBranding = 'vibelux';\n        \n        // Branding configurations\n        const brandingConfigs = {\n            vibelux: {\n                name: 'Vibelux Lighting Design',\n                primary: '#0f172a',\n                secondary: '#1e293b',\n                accent: '#3b82f6'\n            },\n            fluence: {\n                name: 'Fluence Bioengineering',\n                primary: '#7c2d12',\n                secondary: '#a16207',\n                accent: '#d97706'\n            },\n            custom: {\n                name: 'Custom Company',\n                primary: '#312e81',\n                secondary: '#4338ca',\n                accent: '#6366f1'\n            }\n        };\n        \n        function setBranding(brand) {\n            currentBranding = brand;\n            const config = brandingConfigs[brand];\n            \n            // Update CSS variables\n            document.documentElement.style.setProperty('--brand-primary', config.primary);\n            document.documentElement.style.setProperty('--brand-secondary', config.secondary);\n            document.documentElement.style.setProperty('--brand-accent', config.accent);\n            \n            // Update body class\n            document.body.className = `brand-${brand}`;\n            \n            // Update UI elements\n            document.getElementById('company-display').textContent = config.name;\n            document.getElementById('company-preview').textContent = `Current: ${config.name}`;\n            document.getElementById('page-title').textContent = `${config.name} | Report Builder`;\n            document.getElementById('main-title').textContent = `${config.name} | Professional Analysis Report`;\n            \n            // Update branding buttons\n            document.querySelectorAll('.branding-btn').forEach(btn => btn.classList.remove('active'));\n            event.target.classList.add('active');\n            \n            // Update operator company field\n            const operatorCompany = document.querySelector('[data-field=\"company\"]');\n            if (operatorCompany) {\n                operatorCompany.textContent = config.name;\n            }\n        }\n        \n        function openBrandingModal() {\n            document.getElementById('branding-modal').classList.add('active');\n        }\n        \n        function saveCustomBranding() {\n            const companyName = document.getElementById('form-company-name').value;\n            const primaryColor = document.getElementById('form-primary-color').value;\n            const secondaryColor = document.getElementById('form-secondary-color').value;\n            \n            if (!companyName) {\n                alert('Please enter a company name.');\n                return;\n            }\n            \n            // Update custom branding config\n            brandingConfigs.custom.name = companyName;\n            brandingConfigs.custom.primary = primaryColor;\n            brandingConfigs.custom.secondary = secondaryColor;\n            \n            // Apply custom branding\n            setBranding('custom');\n            \n            closeModal('branding-modal');\n            alert('Custom branding applied successfully!');\n        }\n        \n        function editSection(sectionId) {\n            const section = document.getElementById(`section-${sectionId}`);\n            const editables = section.querySelectorAll('.editable');\n            const editBtn = section.querySelector('.control-btn');\n            \n            if (editingSection === sectionId) {\n                // Stop editing\n                editables.forEach(el => el.contentEditable = false);\n                section.classList.remove('editing');\n                editBtn.textContent = 'Edit';\n                editBtn.classList.remove('edit-active');\n                editingSection = null;\n            } else {\n                // Start editing\n                if (editingSection) {\n                    // Stop editing other section first\n                    editSection(editingSection);\n                }\n                editables.forEach(el => el.contentEditable = true);\n                section.classList.add('editing');\n                editBtn.textContent = 'Done';\n                editBtn.classList.add('edit-active');\n                editingSection = sectionId;\n                \n                // Focus first editable element\n                if (editables.length > 0) {\n                    editables[0].focus();\n                }\n            }\n        }\n        \n        function deleteSection(sectionId) {\n            if (confirm('Are you sure you want to remove this section from the report?')) {\n                const section = document.getElementById(`section-${sectionId}`);\n                const checkbox = document.getElementById(sectionId);\n                \n                section.style.display = 'none';\n                checkbox.checked = false;\n            }\n        }\n        \n        function generateReport() {\n            // Stop any current editing\n            if (editingSection) {\n                editSection(editingSection);\n            }\n            \n            // Hide sections based on checkboxes\n            const checkboxes = document.querySelectorAll('input[type=\"checkbox\"]');\n            checkboxes.forEach(checkbox => {\n                const sectionId = `section-${checkbox.id}`;\n                const section = document.getElementById(sectionId);\n                \n                if (section) {\n                    section.style.display = checkbox.checked ? 'block' : 'none';\n                }\n            });\n            \n            alert('Report generated with selected sections! Use the export options to save your customized report.');\n        }\n        \n        function openOperatorModal() {\n            document.getElementById('operator-modal').classList.add('active');\n        }\n        \n        function openIntakeModal() {\n            document.getElementById('intake-modal').classList.add('active');\n        }\n        \n        function openNotesModal() {\n            document.getElementById('notes-modal').classList.add('active');\n        }\n        \n        function closeModal(modalId) {\n            document.getElementById(modalId).classList.remove('active');\n        }\n        \n        function saveOperatorInfo() {\n            // Update the operator information in the report\n            const formData = {\n                'sales-rep': document.getElementById('form-sales-rep').value,\n                'designer': document.getElementById('form-designer').value,\n                'company': document.getElementById('form-op-company').value,\n                'phone': document.getElementById('form-phone').value,\n                'email': document.getElementById('form-email').value,\n                'license': document.getElementById('form-license').value,\n                'report-notes': document.getElementById('form-report-notes').value\n            };\n            \n            // Update the values in the report\n            Object.keys(formData).forEach(field => {\n                const element = document.querySelector(`[data-field=\"${field}\"]`);\n                if (element) {\n                    element.textContent = formData[field];\n                }\n            });\n            \n            closeModal('operator-modal');\n            alert('Operator information updated successfully!');\n        }\n        \n        function saveIntakeInfo() {\n            // Update the intake information in the report\n            const formData = {\n                'client-name': document.getElementById('form-client-name').value,\n                'project-type': document.getElementById('form-project-type').value,\n                'primary-goal': document.getElementById('form-primary-goal').value,\n                'budget-range': document.getElementById('form-budget-range').value,\n                'timeline': document.getElementById('form-timeline').value,\n                'decision-makers': document.getElementById('form-decision-makers').value,\n                'consultation-notes': document.getElementById('form-consultation-notes').value\n            };\n            \n            // Update the values in the report\n            Object.keys(formData).forEach(field => {\n                const element = document.querySelector(`[data-field=\"${field}\"]`);\n                if (element) {\n                    element.textContent = formData[field];\n                }\n            });\n            \n            closeModal('intake-modal');\n            alert('Project information updated successfully!');\n        }\n        \n        function addCustomNote() {\n            const title = document.getElementById('note-title').value;\n            const content = document.getElementById('note-content').value;\n            const type = document.getElementById('note-type').value;\n            \n            if (!title || !content) {\n                alert('Please fill in both title and content for the note.');\n                return;\n            }\n            \n            // Create new note section\n            const noteSection = document.createElement('div');\n            noteSection.className = 'report-section';\n            noteSection.innerHTML = `\n                <div class=\"section-controls\">\n                    <button class=\"control-btn\" onclick=\"editSection('custom-note-${Date.now()}')\">Edit</button>\n                    <button class=\"control-btn\" onclick=\"deleteSection('custom-note-${Date.now()}')\">Remove</button>\n                </div>\n                \n                <div class=\"notes-section\">\n                    <div class=\"notes-title\">\n                        <span class=\"editable\" contenteditable=\"false\">${title}</span>\n                        <span style=\"font-size: 0.8rem; color: #92400e; font-weight: normal;\">(${type})</span>\n                    </div>\n                    <div class=\"notes-content editable\" contenteditable=\"false\">${content}</div>\n                </div>\n            `;\n            \n            // Add to report content\n            document.getElementById('report-content').appendChild(noteSection);\n            \n            // Clear form and close modal\n            document.getElementById('note-title').value = '';\n            document.getElementById('note-content').value = '';\n            closeModal('notes-modal');\n            \n            alert('Custom note added successfully!');\n        }\n        \n        function exportPDF() {\n            alert('PDF export functionality would integrate with your preferred PDF generation library (e.g., jsPDF, Puppeteer)');\n        }\n        \n        function exportWord() {\n            alert('Word export functionality would integrate with a library like docx.js to generate .docx files');\n        }\n        \n        function printReport() {\n            window.print();\n        }\n        \n        // Handle clicking outside modal to close\n        window.addEventListener('click', function(event) {\n            const modals = document.querySelectorAll('.modal');\n            modals.forEach(modal => {\n                if (event.target === modal) {\n                    modal.classList.remove('active');\n                }\n            });\n        });\n        \n        // Initialize with default branding\n        window.addEventListener('load', function() {\n            setBranding('vibelux');\n        });",
          "element": "SCRIPT",
          "class": "",
          "id": "",
          "path": "html > body.brand-vibelux > script"
        }
      ]
    }
  ]
}