/**
 * Automated Progress Tracking and Notifications System
 * Real-time project progress monitoring with intelligent notifications
 */

import type {
  Project,
  ProjectTask,
  ProjectPhase,
  ProjectMilestone
} from '@/lib/project-management/project-types';

// Progress Tracking Types
export interface ProgressUpdate {
  id: string;
  projectId: string;
  taskId?: string;
  phaseId?: string;
  milestoneId?: string;
  type: ProgressUpdateType;
  previousValue: number;
  newValue: number;
  updatedBy: string;
  updatedAt: Date;
  notes?: string;
  evidence?: ProgressEvidence[];
  autoGenerated: boolean;
}

export type ProgressUpdateType = 
  | 'task_progress'
  | 'task_completion'
  | 'phase_progress'
  | 'phase_completion'
  | 'milestone_achieved'
  | 'deliverable_submitted'
  | 'quality_check_passed'
  | 'approval_received';

export interface ProgressEvidence {
  id: string;
  type: 'photo' | 'document' | 'measurement' | 'checklist' | 'signature';
  url: string;
  description: string;
  timestamp: Date;
  location?: {
    latitude: number;
    longitude: number;
  };
  metadata?: Record<string, any>;
}

export interface ProgressMetrics {
  projectId: string;
  calculatedAt: Date;
  
  // Overall metrics
  overallProgress: number;
  schedulePerformance: {
    plannedProgress: number;
    actualProgress: number;
    scheduleVariance: number;
    schedulePerformanceIndex: number;
  };
  
  // Phase metrics
  phaseMetrics: PhaseProgress[];
  
  // Task metrics
  taskMetrics: {
    totalTasks: number;
    completedTasks: number;
    inProgressTasks: number;
    overdueTasks: number;
    upcomingTasks: number;
    averageTaskDuration: number;
    taskCompletionRate: number;
  };
  
  // Milestone metrics
  milestoneMetrics: {
    totalMilestones: number;
    achievedMilestones: number;
    upcomingMilestones: number;
    overdueMilestones: number;
    milestoneHitRate: number;
  };
  
  // Quality metrics
  qualityMetrics: {
    qualityChecksTotal: number;
    qualityChecksPassed: number;
    qualityChecksFailure: number;
    reworkRate: number;
    defectDensity: number;
  };
  
  // Predictive metrics
  predictions: {
    estimatedCompletionDate: Date;
    confidenceLevel: number;
    riskFactors: string[];
    recommendedActions: string[];
  };
}

export interface PhaseProgress {
  phaseId: string;
  phaseName: string;
  plannedProgress: number;
  actualProgress: number;
  variance: number;
  status: 'on_track' | 'at_risk' | 'delayed' | 'completed';
  tasksCompleted: number;
  totalTasks: number;
  milestonesAchieved: number;
  totalMilestones: number;
}

// Notification Types
export interface NotificationRule {
  id: string;
  name: string;
  description: string;
  enabled: boolean;
  projectTypes: string[];
  triggers: NotificationTrigger[];
  recipients: NotificationRecipient[];
  channels: NotificationChannel[];
  template: NotificationTemplate;
  frequency: NotificationFrequency;
  conditions: NotificationCondition[];
  createdAt: Date;
  createdBy: string;
}

export interface NotificationTrigger {
  type: TriggerType;
  threshold?: number;
  timeframe?: number; // hours
  comparison?: 'greater_than' | 'less_than' | 'equal_to' | 'changed';
  field?: string;
}

export type TriggerType =
  | 'task_overdue'
  | 'milestone_missed'
  | 'progress_stalled'
  | 'budget_variance'
  | 'quality_issue'
  | 'schedule_delay'
  | 'resource_conflict'
  | 'approval_required'
  | 'deliverable_due'
  | 'phase_completion'
  | 'daily_digest'
  | 'weekly_report';

export interface NotificationRecipient {
  type: 'user' | 'role' | 'email' | 'team';
  identifier: string;
  name: string;
  preferences: {
    channels: NotificationChannel[];
    frequency: NotificationFrequency;
    quietHours?: {
      start: string; // HH:MM
      end: string;   // HH:MM
      timezone: string;
    };
  };
}

export type NotificationChannel = 'email' | 'sms' | 'push' | 'slack' | 'teams' | 'webhook';
export type NotificationFrequency = 'immediate' | 'hourly' | 'daily' | 'weekly' | 'none';

export interface NotificationTemplate {
  subject: string;
  body: string;
  variables: string[];
  formatting: 'text' | 'html' | 'markdown';
}

export interface NotificationCondition {
  field: string;
  operator: 'equals' | 'not_equals' | 'greater_than' | 'less_than' | 'contains';
  value: any;
  logicalOperator?: 'AND' | 'OR';
}

export interface Notification {
  id: string;
  ruleId: string;
  projectId: string;
  type: TriggerType;
  priority: NotificationPriority;
  title: string;
  message: string;
  data: Record<string, any>;
  recipients: NotificationRecipient[];
  channels: NotificationChannel[];
  status: NotificationStatus;
  createdAt: Date;
  sentAt?: Date;
  readAt?: Date;
  actionTaken?: NotificationAction;
  expiresAt?: Date;
}

export type NotificationPriority = 'low' | 'normal' | 'high' | 'critical';
export type NotificationStatus = 'pending' | 'sent' | 'delivered' | 'read' | 'acted' | 'expired' | 'failed';

export interface NotificationAction {
  type: 'acknowledge' | 'escalate' | 'resolve' | 'snooze' | 'assign';
  takenBy: string;
  takenAt: Date;
  notes?: string;
  data?: Record<string, any>;
}

// Smart Progress Insights
export interface ProgressInsight {
  id: string;
  projectId: string;
  type: InsightType;
  severity: 'info' | 'warning' | 'critical';
  title: string;
  description: string;
  impact: string;
  recommendations: string[];
  confidence: number; // 0-100%
  generatedAt: Date;
  validUntil?: Date;
  relatedTasks?: string[];
  relatedPhases?: string[];
  metrics: Record<string, number>;
}

export type InsightType =
  | 'schedule_prediction'
  | 'resource_bottleneck'
  | 'quality_trend'
  | 'cost_overrun_risk'
  | 'milestone_risk'
  | 'productivity_anomaly'
  | 'dependency_conflict'
  | 'weather_impact'
  | 'resource_optimization';

export class ProgressTracker {
  private notifications: Notification[] = [];
  private rules: NotificationRule[] = [];
  private insights: ProgressInsight[] = [];

  constructor() {
    this.initializeDefaultRules();
  }

  /**
   * Calculate comprehensive progress metrics for a project
   */
  calculateProgressMetrics(project: Project): ProgressMetrics {
    const now = new Date();
    
    // Calculate overall progress
    const overallProgress = this.calculateOverallProgress(project);
    
    // Calculate schedule performance
    const schedulePerformance = this.calculateSchedulePerformance(project, now);
    
    // Calculate phase metrics
    const phaseMetrics = this.calculatePhaseMetrics(project);
    
    // Calculate task metrics
    const taskMetrics = this.calculateTaskMetrics(project);
    
    // Calculate milestone metrics
    const milestoneMetrics = this.calculateMilestoneMetrics(project);
    
    // Calculate quality metrics
    const qualityMetrics = this.calculateQualityMetrics(project);
    
    // Generate predictions
    const predictions = this.generatePredictions(project, overallProgress, schedulePerformance);
    
    return {
      projectId: project.id,
      calculatedAt: now,
      overallProgress,
      schedulePerformance,
      phaseMetrics,
      taskMetrics,
      milestoneMetrics,
      qualityMetrics,
      predictions
    };
  }

  /**
   * Update task progress and trigger notifications
   */
  async updateTaskProgress(
    project: Project,
    taskId: string,
    newProgress: number,
    updatedBy: string,
    notes?: string,
    evidence?: ProgressEvidence[]
  ): Promise<ProgressUpdate> {
    const task = project.tasks.find(t => t.id === taskId);
    if (!task) {
      throw new Error(`Task ${taskId} not found`);
    }

    const previousProgress = task.progress;
    
    // Create progress update record
    const update: ProgressUpdate = {
      id: `update-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      projectId: project.id,
      taskId,
      type: newProgress === 100 ? 'task_completion' : 'task_progress',
      previousValue: previousProgress,
      newValue: newProgress,
      updatedBy,
      updatedAt: new Date(),
      notes,
      evidence,
      autoGenerated: false
    };

    // Update task progress
    task.progress = newProgress;
    task.lastUpdatedBy = updatedBy;
    task.updatedAt = new Date();

    if (newProgress === 100) {
      task.status = 'completed';
      task.endDate = new Date();
    } else if (newProgress > 0 && task.status === 'not_started') {
      task.status = 'in_progress';
    }

    // Check and trigger notifications
    await this.checkProgressTriggers(project, update);
    
    // Update phase progress
    await this.updatePhaseProgress(project, task.phase.id);
    
    // Generate insights
    await this.generateProgressInsights(project);

    return update;
  }

  /**
   * Automatically detect progress updates from various sources
   */
  async detectAutomaticProgress(project: Project): Promise<ProgressUpdate[]> {
    const updates: ProgressUpdate[] = [];
    
    // Check for overdue tasks
    const overdueUpdates = await this.detectOverdueTasks(project);
    updates.push(...overdueUpdates);
    
    // Check for quality check completions
    const qualityUpdates = await this.detectQualityCompletions(project);
    updates.push(...qualityUpdates);
    
    // Check for deliverable submissions
    const deliverableUpdates = await this.detectDeliverableSubmissions(project);
    updates.push(...deliverableUpdates);
    
    // Check for milestone achievements
    const milestoneUpdates = await this.detectMilestoneAchievements(project);
    updates.push(...milestoneUpdates);

    return updates;
  }

  /**
   * Generate smart insights about project progress
   */
  async generateProgressInsights(project: Project): Promise<ProgressInsight[]> {
    const insights: ProgressInsight[] = [];
    const metrics = this.calculateProgressMetrics(project);
    
    // Schedule prediction insights
    if (metrics.schedulePerformance.schedulePerformanceIndex < 0.9) {
      insights.push({
        id: `insight-${Date.now()}-schedule`,
        projectId: project.id,
        type: 'schedule_prediction',
        severity: 'warning',
        title: 'Project Behind Schedule',
        description: `Project is ${Math.abs(metrics.schedulePerformance.scheduleVariance).toFixed(1)}% behind schedule`,
        impact: 'Potential delay in project completion and increased costs',
        recommendations: [
          'Consider adding additional resources to critical path tasks',
          'Review and optimize task dependencies',
          'Implement overtime or weekend work for key activities'
        ],
        confidence: 85,
        generatedAt: new Date(),
        validUntil: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000),
        metrics: {
          scheduleVariance: metrics.schedulePerformance.scheduleVariance,
          spi: metrics.schedulePerformance.schedulePerformanceIndex
        }
      });
    }
    
    // Resource bottleneck detection
    const bottleneckTasks = project.tasks.filter(task => 
      task.status === 'in_progress' && 
      task.assignedTo.length === 0
    );
    
    if (bottleneckTasks.length > 0) {
      insights.push({
        id: `insight-${Date.now()}-resource`,
        projectId: project.id,
        type: 'resource_bottleneck',
        severity: 'critical',
        title: 'Resource Assignment Gaps',
        description: `${bottleneckTasks.length} active tasks lack assigned resources`,
        impact: 'Tasks may stall without proper resource allocation',
        recommendations: [
          'Assign qualified team members to unassigned tasks',
          'Consider hiring additional contractors for specialized work',
          'Redistribute workload among existing team members'
        ],
        confidence: 95,
        generatedAt: new Date(),
        relatedTasks: bottleneckTasks.map(t => t.id),
        metrics: {
          unassignedTasks: bottleneckTasks.length,
          totalActiveTasks: project.tasks.filter(t => t.status === 'in_progress').length
        }
      });
    }
    
    // Quality trend analysis
    if (metrics.qualityMetrics.defectDensity > 0.15) {
      insights.push({
        id: `insight-${Date.now()}-quality`,
        projectId: project.id,
        type: 'quality_trend',
        severity: 'warning',
        title: 'Quality Issues Detected',
        description: `Higher than normal defect rate: ${(metrics.qualityMetrics.defectDensity * 100).toFixed(1)}%`,
        impact: 'Increased rework costs and potential schedule delays',
        recommendations: [
          'Implement additional quality control checkpoints',
          'Provide additional training for team members',
          'Review and update quality procedures'
        ],
        confidence: 78,
        generatedAt: new Date(),
        metrics: {
          defectDensity: metrics.qualityMetrics.defectDensity,
          reworkRate: metrics.qualityMetrics.reworkRate
        }
      });
    }

    this.insights.push(...insights);
    return insights;
  }

  /**
   * Check for notification triggers and send notifications
   */
  private async checkProgressTriggers(project: Project, update: ProgressUpdate): Promise<void> {
    for (const rule of this.rules) {
      if (!rule.enabled) continue;
      if (!rule.projectTypes.includes(project.type)) continue;
      
      const shouldTrigger = await this.evaluateRule(rule, project, update);
      if (shouldTrigger) {
        await this.sendNotification(rule, project, update);
      }
    }
  }

  /**
   * Evaluate if a notification rule should trigger
   */
  private async evaluateRule(
    rule: NotificationRule,
    project: Project,
    update: ProgressUpdate
  ): Promise<boolean> {
    for (const trigger of rule.triggers) {
      const triggered = await this.evaluateTrigger(trigger, project, update);
      if (triggered) {
        return this.evaluateConditions(rule.conditions, project, update);
      }
    }
    return false;
  }

  /**
   * Evaluate a specific trigger
   */
  private async evaluateTrigger(
    trigger: NotificationTrigger,
    project: Project,
    update: ProgressUpdate
  ): Promise<boolean> {
    switch (trigger.type) {
      case 'task_completion':
        return update.type === 'task_completion';
        
      case 'milestone_missed':
        return this.checkMissedMilestones(project);
        
      case 'progress_stalled':
        return this.checkProgressStall(project, trigger.timeframe || 48);
        
      case 'schedule_delay':
        const metrics = this.calculateProgressMetrics(project);
        return metrics.schedulePerformance.scheduleVariance < -(trigger.threshold || 5);
        
      case 'quality_issue':
        return update.type === 'quality_check_passed' && update.newValue === 0;
        
      default:
        return false;
    }
  }

  /**
   * Send notification based on rule
   */
  private async sendNotification(
    rule: NotificationRule,
    project: Project,
    update: ProgressUpdate
  ): Promise<void> {
    const notification: Notification = {
      id: `notif-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      ruleId: rule.id,
      projectId: project.id,
      type: rule.triggers[0].type,
      priority: this.determinePriority(rule.triggers[0].type),
      title: this.generateNotificationTitle(rule, project, update),
      message: this.generateNotificationMessage(rule, project, update),
      data: {
        projectName: project.name,
        updateType: update.type,
        progress: update.newValue
      },
      recipients: rule.recipients,
      channels: rule.channels,
      status: 'pending',
      createdAt: new Date()
    };

    this.notifications.push(notification);
    
    // In a real implementation, this would send via actual channels
    await this.dispatchNotification(notification);
  }

  /**
   * Initialize default notification rules
   */
  private initializeDefaultRules(): void {
    this.rules = [
      {
        id: 'rule-001',
        name: 'Task Completion Alert',
        description: 'Notify project manager when tasks are completed',
        enabled: true,
        projectTypes: ['cogeneration', 'lighting_design', 'hvac_design'],
        triggers: [{ type: 'task_completion' }],
        recipients: [{
          type: 'role',
          identifier: 'project_manager',
          name: 'Project Manager',
          preferences: {
            channels: ['email', 'push'],
            frequency: 'immediate'
          }
        }],
        channels: ['email', 'push'],
        template: {
          subject: 'Task Completed: {{taskName}}',
          body: 'Task "{{taskName}}" has been completed in project {{projectName}}.',
          variables: ['taskName', 'projectName'],
          formatting: 'text'
        },
        frequency: 'immediate',
        conditions: [],
        createdAt: new Date(),
        createdBy: 'system'
      },
      {
        id: 'rule-002',
        name: 'Schedule Delay Warning',
        description: 'Alert when project falls behind schedule',
        enabled: true,
        projectTypes: ['cogeneration', 'lighting_design', 'hvac_design'],
        triggers: [{
          type: 'schedule_delay',
          threshold: 5,
          comparison: 'greater_than'
        }],
        recipients: [{
          type: 'role',
          identifier: 'project_manager',
          name: 'Project Manager',
          preferences: {
            channels: ['email', 'sms'],
            frequency: 'immediate'
          }
        }],
        channels: ['email', 'sms'],
        template: {
          subject: 'Schedule Alert: {{projectName}}',
          body: 'Project {{projectName}} is {{variance}}% behind schedule. Immediate attention required.',
          variables: ['projectName', 'variance'],
          formatting: 'text'
        },
        frequency: 'immediate',
        conditions: [],
        createdAt: new Date(),
        createdBy: 'system'
      }
    ];
  }

  // Helper methods for calculations
  private calculateOverallProgress(project: Project): number {
    if (project.tasks.length === 0) return 0;
    
    const totalWeight = project.tasks.reduce((sum, task) => sum + task.estimatedHours, 0);
    const completedWeight = project.tasks.reduce((sum, task) => 
      sum + (task.estimatedHours * (task.progress / 100)), 0
    );
    
    return totalWeight > 0 ? (completedWeight / totalWeight) * 100 : 0;
  }

  private calculateSchedulePerformance(project: Project, now: Date) {
    const totalDuration = project.plannedEndDate.getTime() - project.plannedStartDate.getTime();
    const elapsedTime = now.getTime() - project.plannedStartDate.getTime();
    const plannedProgress = Math.min(100, (elapsedTime / totalDuration) * 100);
    const actualProgress = this.calculateOverallProgress(project);
    
    const scheduleVariance = actualProgress - plannedProgress;
    const schedulePerformanceIndex = plannedProgress > 0 ? actualProgress / plannedProgress : 1;
    
    return {
      plannedProgress,
      actualProgress,
      scheduleVariance,
      schedulePerformanceIndex
    };
  }

  private calculatePhaseMetrics(project: Project): PhaseProgress[] {
    return project.phases.map(phase => {
      const phaseTasks = project.tasks.filter(task => task.phase.id === phase.id);
      const completedTasks = phaseTasks.filter(task => task.status === 'completed').length;
      const totalTasks = phaseTasks.length;
      
      const plannedProgress = phase.progress;
      const actualProgress = totalTasks > 0 ? (completedTasks / totalTasks) * 100 : 0;
      const variance = actualProgress - plannedProgress;
      
      let status: 'on_track' | 'at_risk' | 'delayed' | 'completed' = 'on_track';
      if (actualProgress === 100) status = 'completed';
      else if (variance < -10) status = 'delayed';
      else if (variance < -5) status = 'at_risk';
      
      return {
        phaseId: phase.id,
        phaseName: phase.name,
        plannedProgress,
        actualProgress,
        variance,
        status,
        tasksCompleted: completedTasks,
        totalTasks,
        milestonesAchieved: 0, // Would calculate from actual milestones
        totalMilestones: 0
      };
    });
  }

  private calculateTaskMetrics(project: Project) {
    const tasks = project.tasks;
    const now = new Date();
    
    return {
      totalTasks: tasks.length,
      completedTasks: tasks.filter(t => t.status === 'completed').length,
      inProgressTasks: tasks.filter(t => t.status === 'in_progress').length,
      overdueTasks: tasks.filter(t => t.endDate < now && t.status !== 'completed').length,
      upcomingTasks: tasks.filter(t => t.startDate > now).length,
      averageTaskDuration: tasks.length > 0 ? tasks.reduce((sum, t) => sum + t.duration, 0) / tasks.length : 0,
      taskCompletionRate: tasks.length > 0 ? tasks.filter(t => t.status === 'completed').length / tasks.length : 0
    };
  }

  private calculateMilestoneMetrics(project: Project) {
    const milestones = project.milestones || [];
    const now = new Date();
    
    return {
      totalMilestones: milestones.length,
      achievedMilestones: milestones.filter(m => m.status === 'completed').length,
      upcomingMilestones: milestones.filter(m => m.targetDate > now).length,
      overdueMilestones: milestones.filter(m => m.targetDate < now && m.status !== 'completed').length,
      milestoneHitRate: milestones.length > 0 ? milestones.filter(m => m.status === 'completed').length / milestones.length : 1
    };
  }

  private calculateQualityMetrics(project: Project) {
    // In a real implementation, this would analyze quality check data
    return {
      qualityChecksTotal: 0,
      qualityChecksPassed: 0,
      qualityChecksFailure: 0,
      reworkRate: 0.05, // 5% estimated rework rate
      defectDensity: 0.08 // 8% estimated defect density
    };
  }

  private generatePredictions(project: Project, overallProgress: number, schedulePerformance: any) {
    const currentRate = schedulePerformance.schedulePerformanceIndex;
    const remainingWork = 100 - overallProgress;
    const remainingTime = project.plannedEndDate.getTime() - Date.now();
    
    // Estimate completion based on current performance
    const estimatedRemainingTime = remainingTime / Math.max(currentRate, 0.1);
    const estimatedCompletionDate = new Date(Date.now() + estimatedRemainingTime);
    
    const riskFactors: string[] = [];
    const recommendedActions: string[] = [];
    
    if (currentRate < 0.9) {
      riskFactors.push('Below target performance rate');
      recommendedActions.push('Increase resource allocation');
    }
    
    if (overallProgress < 50 && remainingTime < (project.plannedEndDate.getTime() - project.plannedStartDate.getTime()) * 0.5) {
      riskFactors.push('Mid-project progress lag');
      recommendedActions.push('Re-evaluate project scope and timeline');
    }
    
    return {
      estimatedCompletionDate,
      confidenceLevel: Math.max(50, 100 - (riskFactors.length * 15)),
      riskFactors,
      recommendedActions
    };
  }

  // Additional helper methods
  private async updatePhaseProgress(project: Project, phaseId: string): Promise<void> {
    const phase = project.phases.find(p => p.id === phaseId);
    if (!phase) return;
    
    const phaseTasks = project.tasks.filter(task => task.phase.id === phaseId);
    const completedTasks = phaseTasks.filter(task => task.status === 'completed').length;
    
    phase.progress = phaseTasks.length > 0 ? (completedTasks / phaseTasks.length) * 100 : 0;
    
    if (phase.progress === 100) {
      phase.status = 'completed';
    } else if (phase.progress > 0) {
      phase.status = 'in_progress';
    }
  }

  private async detectOverdueTasks(project: Project): Promise<ProgressUpdate[]> {
    const now = new Date();
    const overdueTasks = project.tasks.filter(task => 
      task.endDate < now && 
      task.status !== 'completed' &&
      task.status !== 'cancelled'
    );
    
    return overdueTasks.map(task => ({
      id: `auto-${Date.now()}-${task.id}`,
      projectId: project.id,
      taskId: task.id,
      type: 'task_progress' as const,
      previousValue: task.progress,
      newValue: task.progress, // No change, just flagging as overdue
      updatedBy: 'system',
      updatedAt: now,
      notes: 'Task automatically flagged as overdue',
      autoGenerated: true
    }));
  }

  private async detectQualityCompletions(project: Project): Promise<ProgressUpdate[]> {
    // Implementation would check for completed quality checks
    return [];
  }

  private async detectDeliverableSubmissions(project: Project): Promise<ProgressUpdate[]> {
    // Implementation would check for submitted deliverables
    return [];
  }

  private async detectMilestoneAchievements(project: Project): Promise<ProgressUpdate[]> {
    // Implementation would check for achieved milestones
    return [];
  }

  private checkMissedMilestones(project: Project): boolean {
    const now = new Date();
    return (project.milestones || []).some(milestone => 
      milestone.targetDate < now && milestone.status !== 'completed'
    );
  }

  private checkProgressStall(project: Project, hoursThreshold: number): boolean {
    const cutoff = new Date(Date.now() - hoursThreshold * 60 * 60 * 1000);
    return !project.tasks.some(task => 
      task.updatedAt > cutoff && task.progress > 0
    );
  }

  private evaluateConditions(
    conditions: NotificationCondition[],
    project: Project,
    update: ProgressUpdate
  ): boolean {
    if (conditions.length === 0) return true;
    
    // Simplified condition evaluation
    return conditions.every(condition => {
      // Implementation would evaluate each condition
      return true;
    });
  }

  private determinePriority(triggerType: TriggerType): NotificationPriority {
    const priorityMap: Record<TriggerType, NotificationPriority> = {
      'task_overdue': 'high',
      'milestone_missed': 'critical',
      'progress_stalled': 'high',
      'budget_variance': 'high',
      'quality_issue': 'critical',
      'schedule_delay': 'high',
      'resource_conflict': 'high',
      'approval_required': 'normal',
      'deliverable_due': 'normal',
      'phase_completion': 'normal',
      'daily_digest': 'low',
      'weekly_report': 'low',
      'task_completion': 'normal'
    };
    
    return priorityMap[triggerType] || 'normal';
  }

  private generateNotificationTitle(
    rule: NotificationRule,
    project: Project,
    update: ProgressUpdate
  ): string {
    return rule.template.subject
      .replace('{{projectName}}', project.name)
      .replace('{{taskName}}', update.taskId || 'Unknown Task');
  }

  private generateNotificationMessage(
    rule: NotificationRule,
    project: Project,
    update: ProgressUpdate
  ): string {
    return rule.template.body
      .replace('{{projectName}}', project.name)
      .replace('{{taskName}}', update.taskId || 'Unknown Task')
      .replace('{{progress}}', update.newValue.toString());
  }

  private async dispatchNotification(notification: Notification): Promise<void> {
    // Implementation would dispatch to actual notification channels
    logger.info('api', `Notification sent: ${notification.title}`);
    notification.status = 'sent';
    notification.sentAt = new Date();
  }

  // Public methods for accessing data
  getNotifications(projectId?: string): Notification[] {
    return projectId 
      ? this.notifications.filter(n => n.projectId === projectId)
      : this.notifications;
  }

  getInsights(projectId?: string): ProgressInsight[] {
    return projectId 
      ? this.insights.filter(i => i.projectId === projectId)
      : this.insights;
  }

  getRules(): NotificationRule[] {
    return this.rules;
  }
}

